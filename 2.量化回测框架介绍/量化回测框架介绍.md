##### 2. 量化回测框架介绍
###### 2.1 回测框架介绍
**➢ 基础回测框架**

Zipline是一个Pythonic算法交易库，这是一个支持回测和现场交易的事件驱动系统。目前，Zipline被用于生产后测和实时交易引擎，为Quantopian提供动力。是一个免费的，以社区为中性的托管平台。Zipline本身只支持美国的证券，如果我们用需要改很多东西。

**➢ 云端的框架**
- 提供部分满足需求的数据（但是平台数据质量不行，指标不完整）
- 策略运行在远端服务器

**➢ 不去实现一个回测框架的原因**
- 没有完整的股票行情和基本面数据
- 回测平台是载体，<font color='red'>**重点在于快速验证策略**</font>
- 证券投资机构各自使用回测框架不同，没有通用的框架

**➢ RiceQuant回测平台介绍**
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019123115030981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70)
###### 2.2 策略创建运行的流程
**➢ 一个完整的策略需要做的事情**
- 选择策略的运行信息：选择运行区间和初始资金，选择回测频率，选择股票池
- 编写策略的逻辑：获取股票行情、基本面数据
- 分析结果：策略指标分析

**➢ 策略初始设置**
- 基础设置：指定回测的<font color='red'>**起止日期、初始资金和回测频率。**</font>起止日期是策略运行的时间区间；初始资金是用于投资的总资金；回测的频率有两种选择，日回测和分钟回测（对于市场中性，判断周期可能更长，一个月等）。<font color='red'>**做股票量化选择日回测即可**</font>。
- 高级设置：略

**➢ 策略主体运行流程分析**
- 在<font color='red'>**init**</font>函数中实现<font color='red'>**策略初始化逻辑**</font>，策略的股票池：在哪些股票中进行交易判断（例如：HS300）
- 可以选择在<font color='red'>**before_trading**</font>函数进行一些<font color='red'>**每日开盘之前的操作**</font>，比如获取历史行情做一些数据预处理，获取当前账户资金等。
- 在<font color='red'>**handle_bar**</font>函数中实现策略具体逻辑，<font color='red'>**包括交易信号的产生、订单的创建**</font>。handle_bar内的逻辑会在每次bar数据更新的时候被触发。

>**运行顺序：在运行策略时首先运行init函数，但只运行一次。before_trading和handle_bar函数每日都会被调用，每日交易之前首先运行before_trading，然后再运行handle_bar函数进行每日的交易的判断。**

###### 2.3 数据获取接口
**➢ 数据接口的种类**
- 指定行业、板块股票列表
- 指定股票合约历史数据 [ history_bars ]
- 查询财务数据[ get_fundamentals ]

**➢ 获取行业股票列表**

`以获取餐饮业的股票列表为例：`
```py
def init(context):
    # 获取餐饮业股票列表
    context.catering_stock_list = industry('H62')

def before_trading(context):
    # 打印股票列表
    print(context.catering_stock_list)

def handle_bar(context, bar_dict):
	# 主要的算法逻辑
    pass
```
`打印出餐饮业股票列表：`
```py
2019-12-02 INFO ['000721.XSHE', '002306.XSHE', '002186.XSHE']
2019-12-03 INFO ['000721.XSHE', '002306.XSHE', '002186.XSHE']
2019-12-04 INFO ['000721.XSHE', '002306.XSHE', '002186.XSHE']
2019-12-05 INFO ['000721.XSHE', '002306.XSHE', '002186.XSHE']
2019-12-06 INFO ['000721.XSHE', '002306.XSHE', '002186.XSHE']
2019-12-09 INFO ['000721.XSHE', '002306.XSHE', '002186.XSHE']
2019-12-10 INFO ['000721.XSHE', '002306.XSHE', '002186.XSHE']
```
**➢ 获取板块股票列表**

`以获取能源板块列表为例：`
```py
def init(context):
    # 获取能源板块列表
    context.energy_sector_list = sector("Energy")

def before_trading(context):
    # 打印能源板块列表
    print(context.energy_sector_list)

def handle_bar(context, bar_dict):
    # 主要的算法逻辑
    pass
```
`打印能源板块列表：`
```py
2019-12-02 INFO ['600688.XSHG', '600397.XSHG', '600777.XSHG', '002353.XSHE', '000059.XSHE', '300309.XSHE', 
'000937.XSHE', '600028.XSHG', '000159.XSHE', '600583.XSHG', '000968.XSHE', '600871.XSHG', '000552.XSHE', 
'600792.XSHG', '603727.XSHG', '002554.XSHE', '601666.XSHG', '603113.XSHG', '002207.XSHE', '601101.XSHG', 
'600508.XSHG', '600989.XSHG', '300164.XSHE', '002278.XSHE', '000780.XSHE', '600123.XSHG', '600725.XSHG', 
'600759.XSHG', '300191.XSHE', '000406.XSHE', '600997.XSHG', '603800.XSHG', '600403.XSHG', '002018.XSHE', 
'600971.XSHG', '600065.XSHG', '000763.XSHE', '600387.XSHG', '002629.XSHE', '300157.XSHE', '300471.XSHE', 
'601898.XSHG', '601798.XSHG', '603036.XSHG', '000956.XSHE', '600740.XSHG', '600758.XSHG', '600188.XSHG', 
'600968.XSHG', '603798.XSHG', '603619.XSHG', '002128.XSHE', '601808.XSHG', '000698.XSHE', '600002.XSHG', 
'002828.XSHE', '300084.XSHE', '600395.XSHG', '000852.XSHE', '000983.XSHE', '000096.XSHE', '600772.XSHG', 
'601015.XSHG', '600256.XSHG', '601857.XSHG', '601699.XSHG', '000817.XSHE', '000723.XSHE', '002259.XSHE', 
'002221.XSHE', '002490.XSHE', '000866.XSHE', '000571.XSHE', '600348.XSHG', '601088.XSHG', '600121.XSHG', 
'601918.XSHG', '000554.XSHE', '601001.XSHG', '300540.XSHE', '601011.XSHG', '000637.XSHE', '601225.XSHG']
```
**➢ 获取指数成分股**

一般很少选择使用某个行业或某个板块的股票，这些板块的股票很可能不是很好。我们要投的是一些前景比较好的公司，所以我们选择指数成份股票。股票成份股是实时更新的，

`常见的指数成分股有：`
```py
"000001.XSHG" # 上证A股
"000300.XSHG" # HS300，沪深300
"000905.XSHG" # ZZ500，中正500
"000016.XSHG" # SZ50，深圳50
```
`以中正500为例获取中正500的股票列表：`
```py
def init(context):
    # 获取中正500股票列表
    context.zz500_index_components_list = index_components("000905.XSHG")

def before_trading(context):
    # 打印中正500股票列表
    print(context.zz500_index_components_list)

def handle_bar(context, bar_dict):
    # 主要的算法逻辑
    pass
```
`打印中正500的股票列表：`
```py
2019-12-03 INFO ['000587.XSHE', '600008.XSHG', '002157.XSHE', '601958.XSHG', '002589.XSHE', '600307.XSHG', 
'601127.XSHG', '600416.XSHG', '600169.XSHG', '002500.XSHE', '600750.XSHG', '000488.XSHE', '603877.XSHG', 
'002390.XSHE', '603556.XSHG', '600939.XSHG', '600642.XSHG', '002503.XSHE', '600037.XSHG', '601005.XSHG', 
'601699.XSHG', '000552.XSHE', '600183.XSHG', '600694.XSHG', '002670.XSHE', '000559.XSHE', '600820.XSHG', 
'601777.XSHG', '600280.XSHG', '002583.XSHE', '000686.XSHE', '002635.XSHE', '601866.XSHG', '000600.XSHE', 
'300316.XSHE', '603868.XSHG', '600874.XSHG', '603501.XSHG', '000869.XSHE', '601615.XSHG', '600598.XSHG', 
'002131.XSHE', '000727.XSHE', '600884.XSHG', '000513.XSHE', '000541.XSHE', '601168.XSHG', '600393.XSHG', 
'000690.XSHE', '002414.XSHE', '300199.XSHE', '600141.XSHG', '600848.XSHG', '002002.XSHE', '600486.XSHG', 
……
```
**➢ 获取股票合约数据**

使用到的方法（相关参数的解释直接看API文档）：`history_bars(order_book_id, bar_count, frequency, fields=None, skip_suspended=True, include_now=False)`，该模块不可以在`init`方法中调用！！！
>**股票合约数据API文档链接：[https://www.ricequant.com/doc/api/python/chn#data-methods-history_bars](https://www.ricequant.com/doc/api/python/chn#data-methods-history_bars)**

`获取股票合约数据：`

```py
def init(context):
    # 在context中保存全局变量
    context.s1 = "000001.XSHE"

# before_trading函数会在每天策略交易开始前被调用，当天只会被调用一次
def before_trading(context):
    pass

def handle_bar(context, bar_dict):
    # 主要的算法逻辑，必填项
    # order_book_id：获取的历史数据数量，必填项
    # bar_count：获取的历史数据数量，必填项
    # frequency：获取数据什么样的频率进行。'1d'或'1m'分别表示每日和每分钟，必填项。您可以指定不同的分钟频率，例如'5m'代表5分钟线
    # fields：返回数据字段。必填项。
    # skip_suspended：是否跳过停牌，默认True，跳过停牌
    # include_now：是否包括不完整的bar数据。默认为False，不包括。
    # 获取开盘价格
    open_price = history_bars(context.s1,5,'1d','open')
    # 获取其它类型的价格
    history_data = history_bars(context.s1,5,'1d',['open','high','low','close','volume','total_turnover','datetime'])
    logger.info(open_price)
    logger.info(history_data)
    # 如果把频率改成1m，则回测频率必须为分钟回测
    history_data02 = history_bars(context.s1,5,'1m',['open','high','low','close','volume','total_turnover','datetime'])
    print(history_data02)
```
`打印股票合约数据：`
```py
2019-12-02 INFO [15.89 15.64 15.47 15.54 15.35]
2019-12-02 INFO [(15.89, 15.89, 15.49, 15.62, 81529753., 1271594662, 20191126000000)
 (15.64, 15.64, 15.39, 15.47, 47616998.,  736584294, 20191127000000)
 (15.47, 15.54, 15.44, 15.49, 37801651.,  585252046, 20191128000000)
 (15.54, 15.55, 15.18, 15.29, 65386691., 1001451096, 20191129000000)
 (15.35, 15.43, 15.23, 15.36, 55387738.,  849784129, 20191202000000)]
2019-12-03 INFO [15.64 15.47 15.54 15.35 15.3 ]
2019-12-03 INFO [(15.64, 15.64, 15.39, 15.47, 47616998.,  736584294, 20191127000000)
 (15.47, 15.54, 15.44, 15.49, 37801651.,  585252046, 20191128000000)
 (15.54, 15.55, 15.18, 15.29, 65386691., 1001451096, 20191129000000)
 (15.35, 15.43, 15.23, 15.36, 55387738.,  849784129, 20191202000000)
 (15.3 , 15.46, 15.21, 15.45, 45541805.,  700293548, 20191203000000)]
 ……
```