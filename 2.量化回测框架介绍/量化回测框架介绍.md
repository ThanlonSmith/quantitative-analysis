##### 2. 量化回测框架介绍
###### 2.1 回测框架介绍
**➢ 基础回测框架**

Zipline是一个Pythonic算法交易库，这是一个支持回测和现场交易的事件驱动系统。目前，Zipline被用于生产后测和实时交易引擎，为Quantopian提供动力。是一个免费的，以社区为中性的托管平台。Zipline本身只支持美国的证券，如果我们用需要改很多东西。

**➢ 云端的框架**
- 提供部分满足需求的数据（但是平台数据质量不行，指标不完整）
- 策略运行在远端服务器

**➢ 不去实现一个回测框架的原因**
- 没有完整的股票行情和基本面数据
- 回测平台是载体，<font color='red'>**重点在于快速验证策略**</font>
- 证券投资机构各自使用回测框架不同，没有通用的框架

**➢ RiceQuant回测平台介绍**
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019123115030981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70)
###### 2.2 策略创建运行的流程
**➢ 一个完整的策略需要做的事情**
- 选择策略的运行信息：选择运行区间和初始资金，选择回测频率，选择股票池
- 编写策略的逻辑：获取股票行情、基本面数据
- 分析结果：策略指标分析

**➢ 策略初始设置**
- 基础设置：指定回测的<font color='red'>**起止日期、初始资金和回测频率。**</font>起止日期是策略运行的时间区间；初始资金是用于投资的总资金；回测的频率有两种选择，日回测和分钟回测（对于市场中性，判断周期可能更长，一个月等）。<font color='red'>**做股票量化选择日回测即可**</font>。
- 高级设置：略

**➢ 策略主体运行流程分析**
- 在<font color='red'>**init**</font>函数中实现<font color='red'>**策略初始化逻辑**</font>，策略的股票池：在哪些股票中进行交易判断（例如：HS300）
- 可以选择在<font color='red'>**before_trading**</font>函数进行一些<font color='red'>**每日开盘之前的操作**</font>，比如获取历史行情做一些数据预处理，获取当前账户资金等。
- 在<font color='red'>**handle_bar**</font>函数中实现策略具体逻辑，<font color='red'>**包括交易信号的产生、订单的创建**</font>。handle_bar内的逻辑会在每次bar数据更新的时候被触发。

>**运行顺序：在运行策略时首先运行init函数，但只运行一次。before_trading和handle_bar函数每日都会被调用，每日交易之前首先运行before_trading，然后再运行handle_bar函数进行每日的交易的判断。**

###### 2.3 数据获取接口
**➢ 数据接口的种类**
- 指定行业、板块股票列表
- 指定股票合约历史数据 [ history_bars ]
- 查询财务数据[ get_fundamentals ]

**➢ 获取行业股票列表**

`以获取餐饮业的股票列表为例：`
```py
def init(context):
    # 获取餐饮业股票列表
    context.catering_stock_list = industry('H62')

def before_trading(context):
    # 打印股票列表
    print(context.catering_stock_list)

def handle_bar(context, bar_dict):
	# 主要的算法逻辑
    pass
```
`打印出餐饮业股票列表：`
```py
2019-12-02 INFO ['000721.XSHE', '002306.XSHE', '002186.XSHE']
2019-12-03 INFO ['000721.XSHE', '002306.XSHE', '002186.XSHE']
2019-12-04 INFO ['000721.XSHE', '002306.XSHE', '002186.XSHE']
2019-12-05 INFO ['000721.XSHE', '002306.XSHE', '002186.XSHE']
2019-12-06 INFO ['000721.XSHE', '002306.XSHE', '002186.XSHE']
2019-12-09 INFO ['000721.XSHE', '002306.XSHE', '002186.XSHE']
2019-12-10 INFO ['000721.XSHE', '002306.XSHE', '002186.XSHE']
```
**➢ 获取板块股票列表**

`以获取能源板块列表为例：`
```py
def init(context):
    # 获取能源板块列表
    context.energy_sector_list = sector("Energy")

def before_trading(context):
    # 打印能源板块列表
    print(context.energy_sector_list)

def handle_bar(context, bar_dict):
    # 主要的算法逻辑
    pass
```
`打印能源板块列表：`
```py
2019-12-02 INFO ['600688.XSHG', '600397.XSHG', '600777.XSHG', '002353.XSHE', '000059.XSHE', '300309.XSHE', 
'000937.XSHE', '600028.XSHG', '000159.XSHE', '600583.XSHG', '000968.XSHE', '600871.XSHG', '000552.XSHE', 
'600792.XSHG', '603727.XSHG', '002554.XSHE', '601666.XSHG', '603113.XSHG', '002207.XSHE', '601101.XSHG', 
'600508.XSHG', '600989.XSHG', '300164.XSHE', '002278.XSHE', '000780.XSHE', '600123.XSHG', '600725.XSHG', 
'600759.XSHG', '300191.XSHE', '000406.XSHE', '600997.XSHG', '603800.XSHG', '600403.XSHG', '002018.XSHE', 
'600971.XSHG', '600065.XSHG', '000763.XSHE', '600387.XSHG', '002629.XSHE', '300157.XSHE', '300471.XSHE', 
'601898.XSHG', '601798.XSHG', '603036.XSHG', '000956.XSHE', '600740.XSHG', '600758.XSHG', '600188.XSHG', 
'600968.XSHG', '603798.XSHG', '603619.XSHG', '002128.XSHE', '601808.XSHG', '000698.XSHE', '600002.XSHG', 
'002828.XSHE', '300084.XSHE', '600395.XSHG', '000852.XSHE', '000983.XSHE', '000096.XSHE', '600772.XSHG', 
'601015.XSHG', '600256.XSHG', '601857.XSHG', '601699.XSHG', '000817.XSHE', '000723.XSHE', '002259.XSHE', 
'002221.XSHE', '002490.XSHE', '000866.XSHE', '000571.XSHE', '600348.XSHG', '601088.XSHG', '600121.XSHG', 
'601918.XSHG', '000554.XSHE', '601001.XSHG', '300540.XSHE', '601011.XSHG', '000637.XSHE', '601225.XSHG']
```
**➢ 获取指数成分股**

一般很少选择使用某个行业或某个板块的股票，这些板块的股票很可能不是很好。我们要投的是一些前景比较好的公司，所以我们选择指数成份股票。股票成份股是实时更新的，

`常见的指数成分股有：`
```py
"000001.XSHG" # 上证A股
"000300.XSHG" # HS300，沪深300
"000905.XSHG" # ZZ500，中正500
"000016.XSHG" # SZ50，深圳50
```
`以中正500为例获取中正500的股票列表：`
```py
def init(context):
    # 获取中正500股票列表
    context.zz500_index_components_list = index_components("000905.XSHG")

def before_trading(context):
    # 打印中正500股票列表
    print(context.zz500_index_components_list)

def handle_bar(context, bar_dict):
    # 主要的算法逻辑
    pass
```
`打印中正500的股票列表：`
```py
2019-12-03 INFO ['000587.XSHE', '600008.XSHG', '002157.XSHE', '601958.XSHG', '002589.XSHE', '600307.XSHG', 
'601127.XSHG', '600416.XSHG', '600169.XSHG', '002500.XSHE', '600750.XSHG', '000488.XSHE', '603877.XSHG', 
'002390.XSHE', '603556.XSHG', '600939.XSHG', '600642.XSHG', '002503.XSHE', '600037.XSHG', '601005.XSHG', 
'601699.XSHG', '000552.XSHE', '600183.XSHG', '600694.XSHG', '002670.XSHE', '000559.XSHE', '600820.XSHG', 
'601777.XSHG', '600280.XSHG', '002583.XSHE', '000686.XSHE', '002635.XSHE', '601866.XSHG', '000600.XSHE', 
'300316.XSHE', '603868.XSHG', '600874.XSHG', '603501.XSHG', '000869.XSHE', '601615.XSHG', '600598.XSHG', 
'002131.XSHE', '000727.XSHE', '600884.XSHG', '000513.XSHE', '000541.XSHE', '601168.XSHG', '600393.XSHG', 
'000690.XSHE', '002414.XSHE', '300199.XSHE', '600141.XSHG', '600848.XSHG', '002002.XSHE', '600486.XSHG', 
……
```
**➢ 获取股票合约数据**

使用到的方法（相关参数的解释直接看API文档）：`history_bars(order_book_id, bar_count, frequency, fields=None, skip_suspended=True, include_now=False)`，该模块不可以在`init`方法中调用！！！
>**股票合约数据API文档链接：[https://www.ricequant.com/doc/api/python/chn#data-methods-history_bars](https://www.ricequant.com/doc/api/python/chn#data-methods-history_bars)**

`获取股票合约数据：`

```py
def init(context):
    # 在context中保存全局变量
    context.s1 = "000001.XSHE"

# before_trading函数会在每天策略交易开始前被调用，当天只会被调用一次
def before_trading(context):
    pass

def handle_bar(context, bar_dict):
    # 主要的算法逻辑，必填项
    # order_book_id：获取的历史数据数量，必填项
    # bar_count：获取的历史数据数量，必填项
    # frequency：获取数据什么样的频率进行。'1d'或'1m'分别表示每日和每分钟，必填项。您可以指定不同的分钟频率，例如'5m'代表5分钟线
    # fields：返回数据字段。必填项。
    # skip_suspended：是否跳过停牌，默认True，跳过停牌
    # include_now：是否包括不完整的bar数据。默认为False，不包括。
    # 获取开盘价格
    open_price = history_bars(context.s1,5,'1d','open')
    # 获取其它类型的价格
    history_data = history_bars(context.s1,5,'1d',['open','high','low','close','volume','total_turnover','datetime'])
    logger.info(open_price)
    logger.info(history_data)
    # 如果把频率改成1m，则回测频率必须为分钟回测
    history_data02 = history_bars(context.s1,5,'1m',['open','high','low','close','volume','total_turnover','datetime'])
    print(history_data02)
```
`打印股票合约数据：`
```py
2019-12-02 INFO [15.89 15.64 15.47 15.54 15.35]
2019-12-02 INFO [(15.89, 15.89, 15.49, 15.62, 81529753., 1271594662, 20191126000000)
 (15.64, 15.64, 15.39, 15.47, 47616998.,  736584294, 20191127000000)
 (15.47, 15.54, 15.44, 15.49, 37801651.,  585252046, 20191128000000)
 (15.54, 15.55, 15.18, 15.29, 65386691., 1001451096, 20191129000000)
 (15.35, 15.43, 15.23, 15.36, 55387738.,  849784129, 20191202000000)]
2019-12-03 INFO [15.64 15.47 15.54 15.35 15.3 ]
2019-12-03 INFO [(15.64, 15.64, 15.39, 15.47, 47616998.,  736584294, 20191127000000)
 (15.47, 15.54, 15.44, 15.49, 37801651.,  585252046, 20191128000000)
 (15.54, 15.55, 15.18, 15.29, 65386691., 1001451096, 20191129000000)
 (15.35, 15.43, 15.23, 15.36, 55387738.,  849784129, 20191202000000)
 (15.3 , 15.46, 15.21, 15.45, 45541805.,  700293548, 20191203000000)]
 ……
```

> **bar_dict是Bar对象，Bar对象与history_bars的区别是：<font color='red'>Bar只能获取当天的交易数据，不能获取历史交易数据</font>。`logger.info(bar_dict[context.s1].close)：只能获取当前日期的交易信息`。**

**➢ 获取财务数据**

使用`get_fundamentals(query, entry_date=None, interval='1d', report_quarter=False)`方法来查询财务数据。
>**注意：这里的数据指标类别虽然有400多种，但是RQ平台的这些指标数据质量不高，很多指标没有经过运算处理成需要的指标，跟我们在讲金融数据处理的时候列出来的那些财务指标差别比较大。**

使用query查询的方式来获取指标`q = query(fundamentals.eod_derivative_indicator.pe_ratio)`：
```py
def init(context):
    # 在context中保存全局变量
    # context.s1 = "000001.XSHE"
    pass

# before_trading函数会在每天策略交易开始前被调用，当天只会被调用一次
def before_trading(context):
    pass

def handle_bar(context, bar_dict):
    # 获取财务数据，默认是获取所有A股的股票财务数据
    # 创建一个查询语句
    q = query(fundamentals.eod_derivative_indicator.pe_ratio)
    fund = get_fundamentals(q) # 回测不需要传入日期，默认是当天的数据
    logger.info(fund.T)

# after_trading函数会在每天策略交易结束后被调用，当天只会被调用一次
def after_trading(content):
    pass
```
此外还可以设置一些过滤条件来帮助我们选股：
- query().filter()：过滤大小
- query().order_by()：排序
- query().limit()：限制数量
- fundamentals.stockcode.in_()：在指定的股票池当中过滤

`测试使用过滤条件filter过滤股票：`
```py
def init(context):
    # 在context中保存全局变量
    # context.s1 = "000001.XSHE"
    pass

# before_trading函数会在每天策略交易开始前被调用，当天只会被调用一次
def before_trading(context):
    pass

def handle_bar(context, bar_dict):
    # 获取财务数据，默认是获取所有A股的股票财务数据
    # 创建一个查询语句
    q = query(
        fundamentals.eod_derivative_indicator.pe_ratio,
        fundamentals.eod_derivative_indicator.pcf_ratio
    ).filter(
        fundamentals.eod_derivative_indicator.pe_ratio > 20,
        fundamentals.eod_derivative_indicator.pcf_ratio < 50
    )
    fund = get_fundamentals(q) # 回测不需要传入日期，默认是当天的数据
    logger.info(fund.T)

# after_trading函数会在每天策略交易结束后被调用，当天只会被调用一次
def after_trading(content):
    pass
```
`测试结果：`
```py
2019-12-02 09:31:00  INFO              pe_ratio pcf_ratio
000020.XSHE  469.167  -132.305
000023.XSHE  24.2256    14.034
000025.XSHE   74.511  -1304.65
000009.XSHE  36.5007    4.2342
000008.XSHE  27.8938  -16.5274
000021.XSHE  38.9316   33.4623
……
```
`测试使用过滤条件order_by过滤股票：`
```py
def init(context):
    # 在context中保存全局变量
    # context.s1 = "000001.XSHE"
    pass

# before_trading函数会在每天策略交易开始前被调用，当天只会被调用一次
def before_trading(context):
    pass

def handle_bar(context, bar_dict):
    # 获取财务数据，默认是获取所有A股的股票财务数据
    # 创建一个查询语句
    q = query(
        fundamentals.eod_derivative_indicator.pe_ratio,
        fundamentals.eod_derivative_indicator.pcf_ratio
    ).filter(
        fundamentals.eod_derivative_indicator.pe_ratio > 20,
        fundamentals.eod_derivative_indicator.pcf_ratio < 50
    ).order_by(
        fundamentals.eod_derivative_indicator.pe_ratio # 默认按照升序排序，降序使用 fundamentals.eod_derivative_indicator.pe_ratio.asc
    )
    fund = get_fundamentals(q) # 回测不需要传入日期，默认是当天的数据
    logger.info(fund.T)

# after_trading函数会在每天策略交易结束后被调用，当天只会被调用一次
def after_trading(content):
    pass
```
`测试结果：`
```py
2019-12-02 09:31:00  INFO              pe_ratio pcf_ratio
600113.XSHG  20.0129   21.9759
600676.XSHG  20.0165   10.1316
300258.XSHE  20.0204    9.2312
603360.XSHG  20.0549   40.1861
300382.XSHE  20.0974  -47.8644
300485.XSHE  20.1273   27.4275
600731.XSHG  20.1301   20.4888
……
```
`测试使用过滤条件limit过滤股票：`
```py
def init(context):
    # 在context中保存全局变量
    # context.s1 = "000001.XSHE"
    pass

# before_trading函数会在每天策略交易开始前被调用，当天只会被调用一次
def before_trading(context):
    pass

def handle_bar(context, bar_dict):
    # 获取财务数据，默认是获取所有A股的股票财务数据
    # 创建一个查询语句
    q = query(
        fundamentals.eod_derivative_indicator.pe_ratio,
        fundamentals.eod_derivative_indicator.pcf_ratio
    ).filter(
        fundamentals.eod_derivative_indicator.pe_ratio > 20,
        fundamentals.eod_derivative_indicator.pcf_ratio < 50
    ).order_by(
        fundamentals.eod_derivative_indicator.pe_ratio # 默认按照升序排序，降序使用 fundamentals.eod_derivative_indicator.pe_ratio.asc
    ).limit(10)
    fund = get_fundamentals(q) # 回测不需要传入日期，默认是当天的数据
    logger.info(fund.T)

# after_trading函数会在每天策略交易结束后被调用，当天只会被调用一次
def after_trading(content):
    pass
```
`测试结果：`
```py
2019-12-02 09:31:00  INFO              pe_ratio pcf_ratio
600113.XSHG  20.0129   21.9759
600676.XSHG  20.0165   10.1316
300258.XSHE  20.0204    9.2312
603360.XSHG  20.0549   40.1861
300382.XSHE  20.0974  -47.8644
300485.XSHE  20.1273   27.4275
600731.XSHG  20.1301   20.4888
000761.XSHE  20.1325    3.8861
000411.XSHE  20.1383   17.2282
600271.XSHG  20.1523    19.327
2019-12-02 09:32:00  INFO              pe_ratio pcf_ratio
600113.XSHG  20.0129   21.9759
600676.XSHG  20.0165   10.1316
300258.XSHE  20.0204    9.2312
……
```
`测试在指定股票池中（沪深300）过滤股票：`
```py
def init(context):
    # 获取沪深300股票池中的股票
    context.hs300_index_components_list = index_components("000300.XSHG")

# before_trading函数会在每天策略交易开始前被调用，当天只会被调用一次
def before_trading(context):
    pass

def handle_bar(context, bar_dict):
    # 获取财务数据，默认是获取所有A股的股票财务数据
    # 创建一个查询语句
    q = query(
        fundamentals.eod_derivative_indicator.pe_ratio,
        fundamentals.eod_derivative_indicator.pcf_ratio
    ).filter(
        fundamentals.eod_derivative_indicator.pe_ratio > 20,
        fundamentals.eod_derivative_indicator.pcf_ratio < 50
    ).order_by(
        fundamentals.eod_derivative_indicator.pe_ratio # 默认按照升序排序，降序使用 fundamentals.eod_derivative_indicator.pe_ratio.asc
    ).filter(
        fundamentals.stockcode.in_(context.hs300_index_components_list)
    ).limit(10)
    fund = get_fundamentals(q) # 回测不需要传入日期，默认是当天的数据
    logger.info(fund.T)

# after_trading函数会在每天策略交易结束后被调用，当天只会被调用一次
def after_trading(content):
    pass
```
`测试结果：`
```py
2019-12-02 09:31:00  INFO              pcf_ratio pe_ratio
600271.XSHG    19.327  20.1523
601633.XSHG    4.3186  20.2625
002001.XSHE   12.5034  20.3645
601021.XSHG   12.7549  20.4143
002202.XSHE   15.6682  20.5027
600030.XSHG    4.4997  20.5932
000423.XSHE   21.8234  20.6055
600109.XSHG    9.5708  21.1123
000166.XSHE   -8.5859  21.2636
601881.XSHG   42.3332  21.3651
2019-12-02 09:32:00  INFO              pcf_ratio pe_ratio
600271.XSHG    19.327  20.1523
601633.XSHG    4.3186  20.2625
……
```
通过财务数据选股票，不会每天都去获取数据，因为可能获取的股票在近几天是同样的。可以每隔一周、一个月获取一些符合条件的股票。这里可以使用scheduler定时器获取数据，每天运行使用`scheduler.run_daily`，每周运行使用`scheduler.run_weekly`，每月运行`scheduler.run_monthly`。但是，<font color='red'>**这三个定时器函数只能在init函数中使用**</font>。

scheduler.run_daily(function)：每天运行一次的function，只能在init中使用。
>**<font color='red'>注意：init 函数初始化后，如果定时器设置了每月在第一个交易日执行，那么第一个交易日执行 before_trading 函数后，再执行 get_data 函数，最后再执行 after_trading 函数。没有设置定时器的交易日不运行 get_data 函数，只会先后运行before_trading、after_trading函数。</font>** 

参数：
| 参数     | 类型     | 注释                                                         |
| -------- | -------- | ------------------------------------------------------------ |
| function | function | 使传入的function每日运行，function函数一定要包含并且只能包含 **context 和 bar_dict** 两个输入参数 |

`每天运行一次的定时器：`
```py
def init(context):
    # 获取沪深300股票池中的股票
    context.hs300_index_components_list = index_components("000300.XSHG")
    # 定义一个按天运行一次的定时器
    scheduler.run_daily(get_data)

def get_data(context, bar_dict):
    # 按月查询财务数据
    # q = query() # 默认是获取这个月第一天的财务数据
    q = query(
        fundamentals.eod_derivative_indicator.pb_ratio
        ).filter(
            fundamentals.eod_derivative_indicator.pb_ratio > 30
        ).filter(
            fundamentals.stockcode.in_(context.hs300_index_components_list)
        )
    fund = get_fundamentals(q)
    logger.info(fund)

# before_trading函数会在每天策略交易开始前被调用，当天只会被调用一次
def before_trading(context):
    pass

def handle_bar(context, bar_dict):
   pass

# after_trading函数会在每天策略交易结束后被调用，当天只会被调用一次
def after_trading(content):
    pass
```
`测试结果：`
```py
2020-02-03 09:31:00  INFO           002607.XSHE
pb_ratio     40.7768
2020-02-04 09:31:00  INFO           002607.XSHE
pb_ratio     36.6894
2020-02-05 09:31:00  INFO           002607.XSHE
pb_ratio     40.3632
2020-02-06 09:31:00  INFO           002607.XSHE
pb_ratio     40.7525
2020-02-07 09:31:00  INFO           002607.XSHE
pb_ratio     43.7937
2020-02-10 09:31:00  INFO           002607.XSHE
pb_ratio     42.1636
2020-02-11 09:31:00  INFO           002607.XSHE
pb_ratio     42.3583
2020-02-12 09:31:00  INFO           002607.XSHE
pb_ratio     42.8205
2020-02-13 09:31:00  INFO           002607.XSHE
pb_ratio     42.5529
```
scheduler.run_monthly(function, tradingday=t)：每月运行一次的function，只能在init中使用。
>**注意：tradingday的负数表示倒数，tradingday表示交易日，如果某月只有三个交易日，则此月的tradingday=3与tradingday=-1相同。**

参数：
| 参数       | 类型     | 注释                                                         |
| ---------- | -------- | ------------------------------------------------------------ |
| function   | function | 使传入的 function 每日交易开始前运行，function函数一定要包含并且只能包含 **context 和 bar_dict** 两个输入参数 |
| tradingday | int      | 范围为 [-23,1]，[1,23]。例如：1代表每月第一个交易日。-1代表每月倒数第一个交易日，用户必须指定 |

`每月运行一次的定时器：`
```py
def init(context):
    # 获取沪深300股票池中的股票
    context.hs300_index_components_list = index_components("000300.XSHG")
    # 定义一个按月运行的定时器
    # 每月只运行一次并指定第一个交易日
    scheduler.run_monthly(get_data, tradingday=1)

def get_data(context, bar_dict):
    # 按月查询财务数据
    # q = query() # 默认是获取这个月第一天的财务数据
    q = query(
        fundamentals.eod_derivative_indicator.pb_ratio
        ).filter(
            fundamentals.eod_derivative_indicator.pb_ratio > 30
        ).filter(
            fundamentals.stockcode.in_(context.hs300_index_components_list)
        )
    fund = get_fundamentals(q)
    logger.info(fund)

# before_trading函数会在每天策略交易开始前被调用，当天只会被调用一次
def before_trading(context):
    pass

def handle_bar(context, bar_dict):
   pass

# after_trading函数会在每天策略交易结束后被调用，当天只会被调用一次
def after_trading(content):
    pass
```
`测试结果：`

```py
2020-01-02 09:31:00  INFO           002607.XSHE
pb_ratio     43.5018
2020-02-03 09:31:00  INFO           002607.XSHE
pb_ratio     40.7768
```